/**
 * Shadow Config Generator for Sidecar Architecture
 *
 * Generates a wrangler.toml for the Localflare API worker that mirrors
 * the user's bindings. This allows both workers to share the same
 * binding instances in workerd.
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync, cpSync } from 'node:fs'
import { join, dirname } from 'node:path'
import { createRequire } from 'node:module'
import { parseWranglerConfig, type WranglerConfig, type LocalflareManifest } from 'localflare-core'

export type { LocalflareManifest }

/**
 * Find the pre-built worker from localflare-api package
 */
export function getApiWorkerPath(): string {
  const require = createRequire(import.meta.url)
  // main in localflare-api already points to dist/worker/index.js
  return require.resolve('localflare-api')
}

/**
 * Create manifest from wrangler config
 */
export function createManifest(config: WranglerConfig): LocalflareManifest {
  return {
    name: config.name || 'worker',
    d1: (config.d1_databases || []).map((db) => ({
      binding: db.binding,
      database_name: db.database_name,
    })),
    kv: (config.kv_namespaces || []).map((kv) => ({
      binding: kv.binding,
    })),
    r2: (config.r2_buckets || []).map((r2) => ({
      binding: r2.binding,
      bucket_name: r2.bucket_name,
    })),
    queues: {
      producers: (config.queues?.producers || []).map((p) => ({
        binding: p.binding,
        queue: p.queue,
      })),
      consumers: (config.queues?.consumers || []).map((c) => ({
        queue: c.queue,
        max_batch_size: c.max_batch_size,
        max_batch_timeout: c.max_batch_timeout,
        max_retries: c.max_retries,
        dead_letter_queue: c.dead_letter_queue,
      })),
    },
    do: (config.durable_objects?.bindings || []).map((d) => ({
      binding: d.name,
      className: d.class_name,
    })),
  }
}

/**
 * Generate shadow wrangler.toml with bindings from user's config
 * When isPrimary=true, this worker runs as the primary and proxies to user's worker
 */
export function generateShadowConfig(
  config: WranglerConfig,
  apiWorkerPath: string,
  isPrimary: boolean = false
): string {
  const manifest = createManifest(config)
  const userWorkerName = config.name || 'user-worker'

  let toml = `# Auto-generated by Localflare CLI
# DO NOT EDIT - This file is regenerated each time localflare runs

name = "localflare-api"
main = "${apiWorkerPath}"
compatibility_date = "2024-12-01"

[vars]
LOCALFLARE_MANIFEST = '${JSON.stringify(manifest)}'

`

  // If running as primary, add service binding to user's worker
  if (isPrimary) {
    toml += `# Service binding to user's worker (for proxying non-API requests)
[[services]]
binding = "USER_WORKER"
service = "${userWorkerName}"

`
  }

  // Copy D1 databases (preserve preview_database_id if set)
  if (config.d1_databases?.length) {
    for (const db of config.d1_databases) {
      toml += `[[d1_databases]]
binding = "${db.binding}"
database_name = "${db.database_name}"
database_id = "${db.database_id}"
${db.preview_database_id ? `preview_database_id = "${db.preview_database_id}"\n` : ''}`
    }
  }

  // Copy KV namespaces (preserve preview_id if set)
  if (config.kv_namespaces?.length) {
    for (const kv of config.kv_namespaces) {
      toml += `[[kv_namespaces]]
binding = "${kv.binding}"
id = "${kv.id}"
${kv.preview_id ? `preview_id = "${kv.preview_id}"\n` : ''}`
    }
  }

  // Copy R2 buckets (preserve remote, jurisdiction if set)
  if (config.r2_buckets?.length) {
    for (const r2 of config.r2_buckets) {
      toml += `[[r2_buckets]]
binding = "${r2.binding}"
bucket_name = "${r2.bucket_name}"
${r2.remote ? 'remote = true\n' : ''}${r2.jurisdiction ? `jurisdiction = "${r2.jurisdiction}"\n` : ''}`
    }
  }

  // Copy Queue producers (NOT consumers - we only produce)
  if (config.queues?.producers?.length) {
    for (const producer of config.queues.producers) {
      toml += `[[queues.producers]]
binding = "${producer.binding}"
queue = "${producer.queue}"
${producer.delivery_delay ? `delivery_delay = ${producer.delivery_delay}\n` : ''}`
    }
  }

  // Copy Durable Object bindings with script_name reference to user's worker
  // In multi-config mode, this allows localflare-api to access the same DO instances
  if (config.durable_objects?.bindings?.length) {
    for (const doBinding of config.durable_objects.bindings) {
      toml += `[[durable_objects.bindings]]
name = "${doBinding.name}"
class_name = "${doBinding.class_name}"
script_name = "${userWorkerName}"
`
    }
  }

  return toml
}

/**
 * Setup the .localflare directory with shadow config and worker
 * @param isPrimary - If true, localflare-api runs as primary worker and proxies to user's worker
 */
export function setupLocalflareDir(userConfigPath: string, isPrimary: boolean = true): {
  shadowConfigPath: string
  manifest: LocalflareManifest
} {
  const configDir = dirname(userConfigPath)
  const localflareDir = join(configDir, '.localflare')

  // Create .localflare directory
  if (!existsSync(localflareDir)) {
    mkdirSync(localflareDir, { recursive: true })
  }

  // Parse user's config
  const userConfig = parseWranglerConfig(userConfigPath)

  // Get the pre-built worker path
  const apiWorkerPath = getApiWorkerPath()

  // Copy the worker to .localflare
  const localWorkerPath = join(localflareDir, 'api-worker.js')
  cpSync(apiWorkerPath, localWorkerPath)

  // Generate manifest
  const manifest = createManifest(userConfig)

  // Generate shadow config
  const shadowConfig = generateShadowConfig(userConfig, localWorkerPath, isPrimary)

  // Write shadow config
  const shadowConfigPath = join(localflareDir, 'wrangler.toml')
  writeFileSync(shadowConfigPath, shadowConfig)

  // Add .localflare to .gitignore if it exists and doesn't already include it
  const gitignorePath = join(configDir, '.gitignore')
  if (existsSync(gitignorePath)) {
    const gitignore = readFileSync(gitignorePath, 'utf-8')
    if (!gitignore.includes('.localflare')) {
      writeFileSync(gitignorePath, gitignore + '\n# Localflare generated files\n.localflare/\n')
    }
  }

  return { shadowConfigPath, manifest }
}

/**
 * Format bindings for display
 */
export function formatBindings(manifest: LocalflareManifest): string[] {
  const lines: string[] = []

  for (const db of manifest.d1) {
    lines.push(`   - ${db.binding} (D1)`)
  }
  for (const kv of manifest.kv) {
    lines.push(`   - ${kv.binding} (KV)`)
  }
  for (const r2 of manifest.r2) {
    lines.push(`   - ${r2.binding} (R2)`)
  }
  for (const q of manifest.queues.producers) {
    lines.push(`   - ${q.binding} (Queue)`)
  }
  for (const d of manifest.do) {
    lines.push(`   - ${d.binding} (DO)`)
  }

  return lines
}
